### **1015** **Reversible Primes** 

总结 ：素数判断（打印素数表），进制逆转（用while循环实现）

```c++
#include<iostream>
using namespace std;
int n,d,nonprime[100010];
int getreverse(int n,int d)
{
    int s  = 0;
    while(n != 0)
    {
        s = s * d + (n % d);
        n /= d;
    }
    return s;
}

int main()
{
    for(int i = 2;i * i < 100010;++i)
    {
        for(int j = 2;j * i < 100010;++j)
            nonprime[i * j] = 1;
    }
    nonprime[0] = nonprime[1] = 1;
    while(true)
    {
        scanf("%d",&n);
        if(n < 0)
            break;
        scanf("%d",&d);
        if(nonprime[n] || nonprime[getreverse(n,d)])
            cout<<"No\n";
        else 
            cout<<"Yes\n";
    }
    return 0;
}
```

### 1016   **Phone Bills**

<b>考点：</b> 排序

<b>总结 ：</b> 设置容器的时候，注意排序过程中的范围 ：  如果部分没有存入数据会出现排序混乱

```c++
	sort(data.begin(),data.end(),cmp);//这个范围是data[0] 到 data[N-1]
```

注意：scanf输入时要加入地址符& 。

排序是按照名字的字典顺序，时间的先后进行

设计到对事件的计算（这里我按照分钟为单位）

```c++
#include<iostream>
#include<map>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
struct node
{
    string name;
    int time;
    int mouth,day,hour,minute;
    int status;
    bool operator<(const node &e)const 
    {
        if(name != e.name)
            return name < e.name;
        else 
            return time < e.time;
    }
};
int N;
vector<int> rate(25,0);
vector<node> records; 
double bill(node &re)
{
    double total = rate[re.hour]*re.minute + rate[24]*re.day*60;
    
    for(int i = 0;i < re.hour;++i)
    {
        total += rate[i]*60;
    }

    return total/100.0;
}
int main()
{
    for(int i = 0;i < 24;++i)
    {
        cin>>rate[i];

        rate[24] += rate[i];
    }
    cin>>N;
    records.resize(N);
 //   cout<<"--------------------------\n";
    for(int i = 0;i < N;++i)
    {
        cin>>records[i].name;

        scanf("%d:%d:%d:%d",&records[i].mouth,&records[i].day,&records[i].hour,&records[i].minute);
        //cout<<"------------------\n";
        string isOnline;
        cin>>isOnline;

        records[i].status = (isOnline == "on-line" ? 1 : 0);

        records[i].time = records[i].day*24*60 + records[i].hour*60 + records[i].minute;
     //   cout<<"=========ss========\n";
    }


   // cout<<"=============sort====\n";
    sort(records.begin(),records.end());
    map<string,vector<node> > anw;
//利用map存储每个人对应的通话对数
    for(int i = 1;i < N;++i)
    {
        if(records[i].name == records[i - 1].name && records[i-1].status == 1 && records[i].status == 0)
        {
            anw[records[i-1].name].push_back(records[i-1]);
            anw[records[i].name].push_back(records[i]);
        }    
    }

    double total = 0;

    for(auto &it : anw)
    {
        
        //名字 账单月份
        cout<<it.first;
        vector<node> toll = it.second;
       /// cout<<" "<<toll[0].mouth<<endl;
        printf(" %02d\n",toll[0].mouth);
        total = 0;
        for(int i = 1;i < toll.size();i += 2)
        {
            double pert = bill(toll[i]) - bill(toll[i-1]);
            
            //打印开始和结束日期（dd:HH:mm) 持续时间（分钟） 通话费用
            printf("%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\n",toll[i-1].day,toll[i-1].hour,toll[i-1].minute,toll[i].day,toll[i].hour,toll[i].minute,toll[i].time - toll[i-1].time,pert);
            total += pert;
        }

        printf("Total amount: $%.2f\n",total);
    }

    return 0;

}

```

### **1017** **Queueing at Bank** 

考点： 排队，单位的换算。

总结：优先队列，排队是先来先服务的原则。每个客户给定的服务时间以分钟为单位，这里需要全部换算成秒。

优先队列用于存储客户最早完成的时间。队列初始的时间全部设置为8点，每次来一个客户，与队首元素进行比较。如果最早完成的小于等于 当前入队的新用户 ，直接将该新客户的完成时间入队，并且队首元素出队（也就是走掉一个客户）；如果最早完成的大于 当前入队的新用户 则出现等待现象（等待时间为 队首元素即最早完成时间 - 当前用户到来的时间），该客户的完成时间为 队首元素的最早完成时间 + 客户的服务时间,即该新客户的完成时间入队，队首元素出队（走掉一个客户）。依次循环遍历所有用户入队。

```c++
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
struct  Peo
{
    int cost;
    int arriveTime;
    bool operator<(const Peo &e)const
    {
        return arriveTime < e.arriveTime;
    }
}p[10005];
/*bool cmp(Peo &e1,Peo &e2)
{
    return e1.arriveTime < e2.arriveTime;
}*/
int N,K,cnt , total;
int main()
{
    cin>>N>>K;
    for(int i = 1;i <= N;++i)
    {
        int hh,mm,ss,l;
        scanf("%d:%d:%d %d",&hh,&mm,&ss,&l);

        int sum = hh * 60 * 60 + mm * 60 + ss;

        if(sum > 17*60*60)
            continue;

        p[++cnt].cost = l*60;//注意l是以分钟为单位
        p[cnt].arriveTime = sum;
    }

    //sort(p + 1, p + cnt + 1,cmp);
    sort(p + 1, p + cnt + 1);
    priority_queue<int,vector<int>,greater<int> > pq;

    for(int i = 1;i <= K;++i)
        pq.push(8*60*60);

    for(int i = 1;i <= cnt;++i)
    {
        if(pq.top() <= p[i].arriveTime)
        { 
            pq.push(p[i].arriveTime + p[i].cost);
            pq.pop();
        }
        else 
        {
            int topTime = pq.top();
            total += topTime - p[i].arriveTime;
            pq.push(p[i].cost + topTime);
            pq.pop();
        }
    }

    (!cnt) ? printf("0.0\n")  : printf("%.1f\n",((double)total/60)/cnt);


    return 0;
}
```



### **1019** General Palindromic Number

考点： 进制转换，数值逆转

```c
#include<iostream>
#include<algorithm>
#include<vector>
#include<string>
using namespace std;
vector<int> toPalindromic(int number,int base)
{
    vector<int> list;
    if(number == 0)
    {
        list.push_back(0);
        return list;
    }

    while(number != 0)
    {
        int bit = number % base;
        list.push_back(bit);
        number /= base;
    }
    return list;
}
bool isPalindromic(vector<int> list)
{
    int length = list.size();
    for(int i = 0,j = length - 1;i < length/2;i++,j--)
    {
        if(list[i] != list[j])
            return false;
    }
    return true;
}
int main()
{
    int number,base;
    cin>>number>>base;
    vector<int> builder = toPalindromic(number,base);
    cout<<(isPalindromic(builder) ? "Yes\n" : "No\n");
    for(int i = builder.size() - 1;i >= 0;i--)
        printf("%d%s",builder[i],i== 0 ? "\n" : " ");
    
    return 0;

}
```

### **1020** Tree Traversals

考点：二叉树的遍历

总结：根据二叉树的后序遍历和中序遍历，推出二叉树的层序遍历。注意在递归过程中，左子树与右子树的长度是不同的。

在允许范围内都要对进行层序遍历以保证值的存储

```c++
 if(s > e)//等于不行（等于的时候也要分配
        return;
```

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
//后序 和 中序
int postorder[10005],inorder[10005];
int level[10005];
int N;
void solve(int root,int s,int e,int index)
{
    if(s > e)//等于不行（等于的时候也要分配
        return;


    int x = postorder[root];

    level[index] = x;
    //cout<<"level------------------"<<level[index]<<endl;

    int i = s;
    //0-1 1-2 2-3 3-4

    while(i < e && inorder[i] != x)
        ++i;

    int l = i - s;
   // cout<<"i-----------"<<i<<"-----x--"<<inorder[i]<<endl;
    //cout<<"left-------"<<postorder[root - l - 1]<<"right--------------"<<postorder[root - 1]<<endl;    
    //e - i 才是右子树的长度
    solve(root - (e - i) - 1, s , i-1 , 2*index + 1);//左边
    //i- s为左子树的长度
    //cout<<"=================\n";
    solve(root - 1,i+1 , e , 2*index + 2);//右边

}
int main()
{
    memset(level,-1,sizeof(level));
    
    cin>>N;

    for(int i = 0;i < N;++i)
        cin>>postorder[i];
    
    for(int i = 0;i < N;++i)
        cin>>inorder[i];
    
   
    solve(N-1,0,N-1,0);
    int cnt = 1;
    for(int i = 0;i < 10005 && cnt <= N;++i)
    {
        if(level[i] != -1)
        {
            if(cnt != 1)
                cout<<" ";

            cout<<level[i];
            ++cnt;
        }
    }
    return 0;
}
```

### **1021** **Deepest Root** 

考点：连通分量，dfs，图的遍历

总结：如果图的连通分量不是1 ，则输出它的连通分量数；如果图的连通分量为1，则输出构成最深的树的高度时，树的根结点（遍历一个结点所得到的最深结点集合，从该集合中随机挑选任意一个结点再次进行遍历的得到另一个最深结点的集合，这两个集合求并集，即是构成最深的树的高度时，树的根结点集合）

```c++

#include<iostream>
#include<vector>
#include<algorithm>
#include<set>
using namespace std;
vector<vector<int> > G;
vector<bool> visited;
vector<int> temp;
set<int> st;
int max_deep = 0,N;
void dfs(int x,int deep)
{
    visited[x] = true;

    if(deep > max_deep)
    {
        max_deep = deep;
        temp.clear();
        temp.push_back(x);
    }
    else if(deep == max_deep)
    {
        temp.push_back(x);
    }

    for(auto &w : G[x])
    {
        if(!visited[w])
        {
            dfs(w,deep + 1);
        }
    }
}
int main()
{
    cin>>N;
    G.resize(N+1);
    visited.resize(N+1);

    for(int i = 1;i < N;++i)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
        G[y].push_back(x);
    }
    fill(visited.begin(),visited.end(),false);
    int ans = 0,s1;
    for(int i = 1;i <= N;++i)
    {
        if(!visited[i])
        {
            dfs(i,1);
            ++ans;
        }
        if(i == 1)
        {
            s1 = temp[0];
            for(int j = 0;j < temp.size();++j)
                st.insert(temp[j]);
        }
    }
    if(ans >= 2)
    {
        cout<<"Error: "<<ans<<" components\n";
    }
    else 
    {
        max_deep = 0;
        fill(visited.begin(),visited.end(),false);
        temp.clear();
        dfs(s1,1);

        for(int j = 0;j < temp.size();++j)
            st.insert(temp[j]);
        for(auto &c : st)
        {
            cout<<c<<endl;
        }
    }
    return 0;
}
```

### **1023** **Have Fun with Numbers** 

考点：大数运算

总结：本题是给定一个数，查看它的倍数doublenum,是否由其组成的数字排列而成。注意：其倍数最高位是否有进位。

```c++
#include<iostream>
#include<string>
using namespace std;
int book[10];
int main()
{
    string num;
    cin>>num;

    int digit = 0;

    int l = int(num.size());
    for(int i = l - 1;i >= 0;--i)
    {
        int temp = num[i] - '0';
        book[temp]++;

        temp = temp * 2 + digit;

        digit = temp/10;//进位
        temp = temp % 10;//当前位
        num[i] = (temp + '0');
        
        book[temp]--;
    }
    int flag = 0;
    for(int i = 0;i < 10;++i)
    {
        if(book[i] != 0)
            flag = 1;
    }
    cout<<((flag == 1 || digit == 1) ? "No\n" : "Yes\n");
    if(digit == 1)
        cout<<"1";
    cout<<num<<endl;
    return 0;
}
```

### **1024** **Palindromic Number** 

考点：回文数，大数运算

总结：注意处理大数运算过程中的进位问题

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
string additionLargeNum(string str1,string str2)
{
    int l = int(str1.size());
    int digit = 0;
    for(int i = l - 1;i >= 0;--i)
    {
        int temp = (str1[i] - '0')+ (str2[i] - '0') + digit;
        digit = temp/10;
        str1[i] = (temp%10) + '0';
    }

    if(digit)
        str1 = to_string(digit) + str1;
    return str1;
}
int main()
{
    string str;
    cin>>str;
    int k;
    cin>>k;
    
    int i = 1;
    for(;i <= k;++i)
    {
        string ctr = str;
        reverse(ctr.begin(),ctr.end());
        if(ctr == str)
            break;
        str = additionLargeNum(str,ctr);
    }
    cout<<str<<endl;
    cout<<i-1<<endl;
    return 0;
}
```

### **1025** **PAT Ranking**

考点：排序

总结：分集合排序，合并排序。注意在合并的过程中不要漏掉元素

```c++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;
int N,K;
struct node
{
    string name;
    int final_rank;
    int location_number;
    int local_rank;
    int score;
};
bool cmp1(node &e1,node &e2)
{
    if(e1.score != e2.score)
         return e1.score > e2.score;
    else 
        return e1.name < e2.name;
}
vector<node> mergedRanklist;
int main()
{
    cin>>N;

    for(int i = 0;i < N;++i)
    {
        cin>>K;
        vector<node> t(K);
        for(int j = 0;j < K;++j)
        {
            string id;
            int sc;
            cin>>id>>sc;
            t[j].name = id;
            t[j].score = sc;
            t[j].location_number = i + 1;
       
        }

        sort(t.begin(),t.end(),cmp1);

        t[0].local_rank = 1;
        mergedRanklist.push_back(t[0]);
        for(int i = 1;i < t.size();++i)
        {
            t[i].local_rank = i + 1;
            if(t[i].score == t[i-1].score)
                t[i].local_rank = t[i-1].local_rank;
            
            mergedRanklist.push_back(t[i]);
        }
    }
    sort(mergedRanklist.begin(),mergedRanklist.end(),cmp1);
    mergedRanklist[0].final_rank = 1;
    for(int i = 1;i < mergedRanklist.size();++i)
    {
        mergedRanklist[i].final_rank = i + 1;
        if(mergedRanklist[i].score == mergedRanklist[i - 1].score)
            mergedRanklist[i].final_rank = mergedRanklist[i-1].final_rank;
    }
    cout<<mergedRanklist.size()<<endl;
    for(auto &e : mergedRanklist)
    {
        cout<<e.name<<" "<<e.final_rank<<" "<<e.location_number<<" "<<e.local_rank<<endl;
    }
    return 0;
}
```

### **1027** **Colors in Mars** 

考点：进制转换，字符处理

总结：题目大致意思是将给定的十进制转换为13进制的形式，并且13进制的宽度为2，也就是不足两位填0即可。特别注意的是10到12用大写字母表示，这里利用字符串进行存储，以对应下标的形式将其输出即可。

```c++
#include<iostream>
#include<vector>
using namespace std;
int getRadix(int x)
{
    return (x/13)*10 + (x%13);
}
char signTable[14] ="0123456789ABC";
int main()
{
    int a,b,c;
    cin>>a>>b>>c;


    printf("#");
    printf("%c%c%c%c%c%c",signTable[a/13],signTable[a%13],signTable[b/13],signTable[b%13],signTable[c/13],signTable[c%13]);
    return 0;
}
```

### **1031** **Hello World for U** 

考点：字符串处理，公式计算

总结：题意大致：将字符串平分三分，两边的高度相等尽可能大（也就是向下取整 ）。剩下的长度就是两边字符之间所夹着的字符的个数了（也是两边之间空格的个数）。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str;
    getline(cin,str);

    int l = int(str.size());
    int n = (l + 2)/3;//n1和n2的长度

  //  cout<<"n--------"<<n<<endl;

    int bm = l - 2*n; //bm + 2就是 n3的长度
    int i;
   // cout<<"bm--------"<<bm<<endl;
    for(i = 0;i < n - 1;++i)
    {
        cout<<str[i];
        for(int j = 0;j < bm;++j)
            cout<<" ";
        cout<<str[l - i - 1]<<endl;
    }
    
    for(;i <= n + bm;++i)
        cout<<str[i];
    //cout<<"-------i"<<i<<endl;


    return 0;
}		
```

### **1035** **Password** 

考点：字符串的处理

总结：注意输出格式的要求，在所有密码都不需要修改的情况下，注意n的单复数形式在英文中的表达方式

```c++
cout<<"There "<<(n == 1 ? "is" : "are")<<" "<<n<<" account"<<(n == 1 ? "" : "s")<<" and no account is modified\n";
```

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
using pii = pair<string,string>;
vector<pii> re;
int ans;
char modified(char c)
{
    
    if(c == '0')
    {
        return '%';
    }
    else if(c == 'l')
    {
        return 'L';
    }else if(c == '1')
    {
        return '@';
    }else if(c == 'O')
    {
        return 'o';
    }
    else 
    {
        ++ans;
        return c;
    }

}
int main()
{
    int n;
    cin>>n;
    int cnt = 0;
    for(int i = 0;i < n;++i)
    {
        ans = 0;
        string str1,str2;
        cin>>str1>>str2;
        for(int j = 0;j < str2.size();++j)
        {
            str2[j] = modified(str2[j]);
        }
        if(ans != str2.size())
        {
            ++cnt;
            re.push_back({str1,str2});
        }
    }
    if(cnt == 0)
    {
        cout<<"There "<<(n == 1 ? "is" : "are")<<" "<<n<<" account"<<(n == 1 ? "" : "s")<<" and no account is modified\n";
    }
    else 
    {
        cout<<cnt<<endl;
        for(auto &w : re)
        {
            cout<<w.first<<" "<<w.second<<endl;
        }
    }
}
```

### **1041** **Be Unique**

考点：

总结：标记第一个出现的且在集合中不重复的数字

```c++
#include<iostream>
#include<vector>
using namespace std;
int flag[100005];
int main()
{
    int n;
    cin>>n;
    vector<int> st;
    for(int i = 0;i < n;++i)
    {
        int x;
        cin>>x;
        flag[x]++;
        st.push_back(x);
    }
    bool winer = false;
    for(auto &e : st)
    {
        if(flag[e] == 1)
        {
            winer = true;
            cout<<e<<endl;
            break;
        }
    }
    cout<<(!winer ? "None\n" : "");
    return 0;
}
```

### **1042** **Shuffling Machine** 

考点：数组

总结：题目给定循环的次数以及洗牌过程中每张牌所应放的位置

```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
using namespace std;
vector<string> st(54);
int start[55],ed[55],scan[55];
int main()
{
    char M[5] = {'S','H','C','D','J'};
    for(int i = 0;i < 54;++i)
    {
        int index = (i % 13) + 1;
        int ic = (i / 13);
        char c = M[ic];
        st[i].push_back(c);

        st[i] = st[i] + to_string(index);
    }
   /* for(int i = 0;i < 54;++i)
        cout<<" "<<st[i];
    cout<<endl;*/
    int n;
    cin>>n;
    vector<int> order;
    for(int i = 0;i < 54;++i)
    {
        int x;
        cin>>x;
        //i移动到 x
        scan[i] = x-1;
        //结束的位置
        ed[i] = i;
    }
    for(int j = 0;j < n;++j)
    {
        for(int i = 0;i < 54;++i)
        {
            start[i] = ed[i];//开始的位置
        }
        for(int i = 0;i < 54;++i)
        {
           ed[scan[i]] = start[i];//结束的位置
        }
    }
    for(int i = 0;i < 54;++i)
    {
        cout<<(i != 0 ? " " : "")<<st[ed[i]];
    }
    cout<<endl;
    return 0;
}
//S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5
/*
1
36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47
*/
```

### **1046** **Shortest Distance** 

考点：数组

总结：循环路径，计算x,y两点的两个路径的最小值即可。（sum为圈的总长，dis[y-1] - dis[x-1]为两点之间的长度。剩下的是另一条路的长度。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int dis[100005];
int main()
{
    int n;
    cin>>n;
    int sum = 0;
    for(int i = 1;i <= n;++i)
    {
       cin>>dis[i];
       sum += dis[i];
       dis[i] = sum;
    }
    int k;
    cin>>k;
    while(k--)
    {
        int x,y;
        cin>>x>>y;
        if(x > y)
            swap(x,y);
        int temp = dis[y - 1] - dis[x-1];
        cout<<min(temp,sum - temp)<<endl;
    }
    return 0;
}
```

###  **1050** **String Subtraction**

考点：字符串

总结： 用set容器判断是否第一个字符串中的字符是否在第二个字符串中出现过。

```c++
#include<iostream>
#include<string>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
int main()
{
    set<char> st;
    string str1,str2;
    getline(cin,str1);
    getline(cin,str2);
    for(auto &c : str2)
    {
        st.insert(c);
    }
    for(auto &w : str1)
    {
        if(!st.count(w))
            cout<<w;
    }

    return 0;
}
```

### **1054** **The Dominant Color**

考点：

总结：找到出现次数最多的元素

```c++
#include<iostream>
#include<map>
#include<string>
using namespace std;
string answer;
map<string,int> ms;
int M,N,max_cnt = 0;
int main()
{
    cin>>M>>N;
    for(int i = 0;i < M;++i)
    {
        for(int j = 0;j < N;++j)
        {
            string color;
            cin>>color;
            ms[color]++;
            if(max_cnt < ms[color])
            {
                max_cnt = ms[color];
                answer = color;
            }
        }
    }
    cout<<answer<<endl;
    return 0;;
}
```

### **1058** **A+B in Hogwarts**

考点：大数运算

总结：考虑进位的情况

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int a1,a2,a3,b1,b2,b3;
    scanf("%d.%d.%d %d.%d.%d",&a1,&a2,&a3,&b1,&b2,&b3);
    int digit;
    digit = (a3 + b3) / 29;
    a3 = (a3 + b3) % 29;
    int sum = a2 + b2 + digit;
    a2 = sum % 17;
    digit = sum / 17;
    a1 = (a1 + b1 + digit);

    printf("%d.%d.%d",a1,a2,a3);
    return 0;
}
```

### **1061** **Dating** 

考点：字符串处理

总结：注意相同字符的判断（两个字符串中第几个相同的字符），对相同的字符的形式区分（A-G, 0-9，A - N,大小写，)

```c++
#include<iostream>
#include<string>
#include<set>
using namespace std;
int main()
{
    string str1,str2;
    string day[7]  = {"MON","TUE","WED","THU","FRI","SAT","SUN"};
    getline(cin,str1);
    getline(cin,str2);
    char firstC,secondC;
    int j = 0;
    while(j < str1.size() && j < str2.size())
    {
        if(str1[j] == str2[j] && (str1[j] <= 'G' && str1[j] >= 'A'))
            break;

        ++j;
    }
    firstC = str1[j];
    ++j;
    while(j < str1.size() && j < str2.size())
    {
        if((str1[j] == str2[j] && ((str1[j] >= 'A' && str1[j] <= 'N') || isdigit(str1[j]))))
            break;
        ++j;
    }
    secondC = str1[j];
 //   cout<<"========="<<secondC<<endl;
    string dt = day[firstC - 'A'];
    int hh = (isdigit(secondC) ? (secondC - '0') : (secondC - 'A' + 1) + 9);
    getline(cin,str1);
    getline(cin,str2);
    int l1 = int(str1.size()), l2 = int(str2.size());
    int i = 0;
    while(i < l1 && i < l2)
    {
        if(str1[i] == str2[i] && isalpha(str1[i]))
            break;
        ++i;
    }
    int mm = i;
    cout<<dt<<" ";
    printf("%02d:%02d\n",hh,mm);
    return 0;
}
```

### **1101** **Quick Sort** 

考点：快速排序，主元的位置

总结：两个数组分别存放初始位置以及排序后的位置，初始位置对应排序后的位置一致就可能是pivot（此时再比较其左边最大元素是否超过其大小，如果左边元素的最大值没有超过该数值，即为枢轴）。

最后没有找到为什么输出格式要在最后换行。

```c++
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
vector<int> a,b;
set<int> st;
int N;
int main()
{
    int max_left = 0;
    cin>>N;
    a.resize(N);
    b.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>a[i];
        b[i] = a[i];
    }
    sort(a.begin(),a.end());
    for(int i = 0;i < N;++i)
    {
        if(a[i] == b[i] && max_left < b[i])
            st.insert(b[i]);
        max_left = max(max_left,b[i]);
    }
    int cnt = int(st.size());
    cout<<cnt<<endl;
    int i = 0;
    for(auto &w : st)
    {
        cout<<((i++)!= 0 ? " " : "")<<w;
    }
    cout<<endl;
    return 0;
}
```

### **1100** **Mars Numbers** 

考点：字符串，取余操作，进制数

总结：判断是火星文还是地球文。火星文：注意有几位数，找到对应数值的下标即可。地球文：判断高位如果有高位，注意是否有低位，有高位并且有低位才输出空格。低位输出分两种（非零值和零值）。0-168 （0 ~ 12,13 ~168）。还要特别注意输出格式。

0 和 130的特殊情况

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
string onedig[13] = {"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"};
string secdig[13] = {"###","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"};
int N;
//注意，还有个数字0没有考虑，因为数字0取余13等于0，但是要特别输出tret，所以在func1的最后一句判断中加一句t == 0，
//并将a[0]位赋值成tret即可解决0的问题～
void fun1(string str)
{
    int  num = stoi(str);

    int firstdigit = num % 13;
    int seconddigit = num / 13;
    if(seconddigit)
    {
        cout<<secdig[seconddigit];
    }
    if((seconddigit)&&(firstdigit))
        cout<<" ";
    if(firstdigit || num == 0)
          cout<<onedig[firstdigit];
}
void fun2(string str)
{
    int  t1 = 0, t2  = 0;
    string s1 = str.substr(0,3),s2;

    if(str.length() > 4)
        s2 = str.substr(4,3);

    for(int j = 1;j <= 12;++j)
    {
        if(s1 == onedig[j] || s2 == onedig[j]) 
            t2 = j;

        if(s1 == secdig[j])
            t1 = j;
    }
    cout<<t1 * 13 + t2;
}
int main()
{
   cin>>N;
   getchar();
   while(N--)
   {
       string str;
       getline(cin,str);
       string s1,s2;
       if(isdigit(str[0]))
       {
            fun1(str);
       }
       else 
       {
           fun2(str);
       }
       cout<<endl;
   }
    return 0;
}
```

### **1154** **Vertex Coloring** 

考点：图的存储，DFS,BFS,并查集

总结：有向图，无向图

```c++
//深度优先搜索
#include<iostream>
#include<vector>
#include<set>
#include<algorithm>
using namespace std;
int N,M,K;
vector<vector<int> > G;
vector<int> color;
vector<bool> visited;
bool flag;
void dfs(int x)
{
    if(!flag)
        return;
    visited[x] = true;
    for(auto &w :G[x])
    {
        if(color[x] == color[w])
            {flag = false;
            break;}

        if(!visited[w])
        {
           dfs(w);
        }
    }
}
bool judge()
{
    fill(visited.begin(),visited.end(),false);
    flag = true;
    for(int i = 0;i < N;++i)
    {
        if(!visited[i])
            dfs(i);
    }
    return flag;
}
int main()
{
    cin>>N>>M;
    G.resize(N);
    color.resize(N);
    visited.resize(N);
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
        
    }
    cin>>K;
    while(K--)
    {
        set<int> st;
        for(int i = 0;i < N;++i)
        {
            cin>>color[i];
            st.insert(color[i]);
        }
        int  num = st.size();
        if(judge())
        {
            cout<<num<<"-coloring\n";
        }
        else 
        {
            cout<<"No\n";
        }
    }
    return  0;
}
```

另一种dfs

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<set>
using namespace std;
vector<vector<int> > G;
vector<bool> visited;
vector<int> color;
set<int> st;
int N,M,k;
bool dfs(int x)
{
    visited[x] = true;
    for(auto &w : G[x])
    {
        if(color[w] == color[x])
            return false;
        if(!visited[w]&&!dfs(w))
            return false;
    }
    return true;
}
bool judge()
{
    fill(visited.begin(),visited.end(),false);
    for(int i = 0;i < N;++i)
    {
        if(!visited[i]&&!dfs(i))
            return false;
    }
    return true;
}
int main()
{
    cin>>N>>M;
    visited.resize(N);
    G.resize(N);
    color.resize(N);

    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        G[x].push_back(y);
    }
    cin>>k;
    while(k--)
    {
        set<int> colornum;
        for(int i = 0;i < N;++i)
        {
            cin>>color[i];
            colornum.insert(color[i]);
        }
        int num = colornum.size();

       if(judge())
        {
            cout<<num<<"-coloring\n";
        }
        else 
        {
            cout<<"No\n";
        }
    }
    return 0;
}	
```

方法三：

```c
#include<iostream>
#include<vector>
#include<set>
using namespace std;
using pii = pair<int,int>;
int connect[10005][10005];
vector<int> color;
vector<pii> edge;

int N,M,K;
bool judge()
{
    for(auto &e : edge)
    {
        int x = e.first, y = e.second;
        if(color[x] == color[y])
            return false;
    }
    return true;
}
int main()
{
    cin>>N>>M;
    color.resize(N);

    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        connect[x][y] = connect[y][x] = 1;
        edge.push_back({x,y});
    }
    cin>>K;
    while(K--)
    {
        set<int> colornum;
        for(int i = 0;i < N;++i)
        {
            cin>>color[i];
            colornum.insert(color[i]);
        }
        if(judge())
        {
            cout<<colornum.size()<<"-coloring\n";
        }
        else 
        {
            cout<<"No\n";
        }
    }
    return 0;
}
```

### **1098** **Insertion or Heap Sort** 

考点：插入排序，堆排序

总结：插入排序，题目中未排序序列位于排序序列的后侧；堆排序，未排序序列位于排序序列的前侧。要熟悉堆排序中，未排序序列的堆调整的过程；插入排序的排序过程。注意：本题中，堆排序中未排序序列的首部始终为最大值（满足堆的性质）

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int N;
vector<int> a,b;
void adjustHeap(int low,int high)
{
    //第一个元素为堆顶元素
    int i = low,j = 2*i;
    //大根堆做下沉操作
    while(j <= high)
    {
        //找到孩子节点最大的与其交换位置
        if(j + 1 <= high && b[j + 1] > b[j])
                ++j;
        if(b[j] > b[i])
        {
            swap(b[j],b[i]);
            i = j;
            j = 2*i;
        }
        else 
        {
            break;
        }
    }
}
int main()
{
    cin>>N;
    a.resize(N+1);
    b.resize(N+1);
    for(int i = 1;i <= N;++i)
        cin>>a[i];
    for(int i = 1;i <= N;++i)
        cin>>b[i];

    int  p = 2;
    //判断是否是插入排序，前面是否已经排好
    while(p <= N && b[p-1] <= b[p])
        ++p;
    int index = p;//插入排序过程中未排序序列中的第一个元素
    ///后面是否和初始相同
    while(p <= N && a[p] == b[p])
        ++p;
    if(p == N + 1)
    {

        cout<<"Insertion Sort\n";
        sort(b.begin() + 1,b.begin() + index + 1);
        for(int i = 1;i <= N;++i)
        {
            cout<<(i != 1 ? " " : "")<<b[i];
        }
        cout<<endl;
    }
    else 
    {
        cout<<"Heap Sort\n";
        p = N;
        //找到堆排序中未排序序列的最后元素的位置
        while(p >= 2 && b[p-1] <= b[p])
            --p;
            //此时p的位置为为排序序列的末尾
        //--p;
        swap(b[1],b[p]);//第一个元素为未排序序列中的最大值，将其插入到排序序列的首部
        //对未排序序列进行堆调整
        adjustHeap(1,p-1);
        for(int i = 1;i <= N;++i)
        {
            cout<<(i != 1 ? " " : "")<<b[i];
        }
        cout<<endl;
    }
    
    return 0;
}
```

### **1152** **Google Recruitment**

考点：字符串

总结：注意边界情况

```c++
 for(int i = 0;i < str.size() - K + 1;++i)//最后k个字符的开始下标为：str.size() - k (下标从0开始)
```



```c++
#include<iostream>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
bool judge(int x)
{
    for(int i = 2;i <= sqrt(x);++i)
    {
        if(x % i == 0)
            return false;
    }
    return true;
}
int  N,K;
int main()
{
    cin>>N>>K;
    getchar();
    string str,answer = "";
    getline(cin,str);
    
    for(int i = 0;i < str.size() - K + 1;++i)
    {
        string testnum = str.substr(i,K);
        if(judge(stoi(testnum)))
        {
            answer = testnum;
            break;
        }
    }
    cout<<(answer != "" ? answer+"\n" : "404\n");

    return 0;
}
```

### **1148** **Werewolf - Simple Version**

考点：模拟题，枚举

总结：条件：有两个说谎的人，一个是狼人一个不是狼人。枚举两个狼人，根据player的说话信息（某人是不是狼人）判断其与枚举情况是否符合，将不符合（也就是说谎的人存入集合），当找到第一个符合条件的集合即为答案。

```c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
int main()
{
    int N;
    cin>>N;
    vector<int> talk(N + 1,0);
    for(int i = 1;i <= N;++i)
        cin>>talk[i];
    for(int i = 1;i <= N;++i)
    {
        for(int j = i + 1;j <= N;++j)
        {
            //1不是两人，-1是两人
            vector<int> a(N+1,1);
            a[i] = a[j] = -1;
            vector<int> lying;
            for(int k = 1;k <= N;++k)
            {
                //判断说话的人是否说谎
                int id = abs(talk[k]);
                //如果说谎则异号
                if(a[id]*talk[k] < 0)
                    lying.push_back(k);
            }
            //有两个人说谎，并且一个是狼人，一个不是狼人
            if(lying.size() == 2 && a[lying[0]] + a[lying[1]] == 0)
            {
                cout<<i<<" "<<j<<endl;
                return 0;
            }
        }
    }
    cout<<"No Solution\n";
    return 0;
}
```

### **1144** **The Missing Number** 

考点：数组

总结：用数组下标记录对应正整数是否出现过，注意段错误（数组越界）这里我该用了map容器，不再list中的最小正整数的范围则为1~N+1。

```c++
#include<iostream>
#include<map>
#include<algorithm>
using namespace std;
int N;
int main()
{
    cin>>N;
    map<int,int> MarkArray;
    for(int i = 0;i < N;++i)
    {
        int num;
        cin>>num;
        MarkArray[num]++;
    }
    int i = 1;
    for(;i <= N;++i)
    {
        if(MarkArray[i] == 0)
            break;
    }
    cout<<i<<endl;
    return 0;
}
```

### **1140** **Look-and-say Sequence** 

考点：字符串

总结：原有表达式 A=A+B改为A+=B这样不仅减少了敲入代码的数量，而且由于变量A只出现一次，在运行时也提高了系统的性能。否则可能会出现，运行超时：您的程序未能在规定时间内运行结束

```c++
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main()
{
   string str;
   int N;
   int j;
   cin>>str>>N;
   for(int cnt = 1;cnt < N;++cnt)
   {
     //  int len = int(str.size());
       string t;
       for(int i = 0;i < str.size();i = j)
       {
           for(j = i;j < str.size() && str[j] == str[i];j++);
           /*
           例如原有表达式 A=A+B
改为A+=B
这样不仅减少了敲入代码的数量，而且由于变量A只出现一次，在运行时也提高了系统的性能。*/
           t += str[i] + to_string(j - i);//这里会超时 x+=y等价于x=x+y和类型强制转换两个操作。
       }
       str = t;
   }
   cout<<str<<endl;
   return 0;
}
```

### **1136** **A Delayed Palindrome**

考点：字符串，大数运算，回文数

总结：判断一个数是否文回文数，不是回文数进行给定条件的加法操作，最多判断10次。注意：先判断在进行加法操作。

```c++
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
string getCount(string str)
{
    string sum = str;
    int len = int(str.size());
    int digit = 0;
    int j = len - 1,i = 0;
    for(;i < len && j >= 0;++i,--j)
    {
        int x = (sum[j] - '0') + (str[i] - '0') + digit;
        sum[j] = (x%10 + '0');
        digit = x/10;
    }
    if(digit)
        sum = to_string(digit) + sum;
    return sum;
}
bool Ispalindromic(string str)
{
    int len = int(str.size());
    for(int i = 0;i < len/2;++i)
    {
        if(str[i] != str[len - 1 - i])
            return false;
    }
    return true;
}
int main()
{
    string str;
    getline(cin,str);
    int i;
    for(i = 0;i < 10;++i)
    {
        string ctr = str;
        reverse(ctr.begin(),ctr.end());
        if(Ispalindromic(str))
        {
            cout<<str<<" is a palindromic number.\n";
            break;
        }
        string x = getCount(str);
        cout<<str<<" + "<<ctr<<" = "<<x<<endl;
        str = x;
    }
    if(i == 10)
        cout<<"Not found in 10 iterations.\n";
    return 0;
}
```

### **1132** **Cut Integer**

考点：除法操作，浮点错误

总结：出现浮点错误，一般是指您的程序运行时发生浮点错误，比如遇到了除以 0 的情况

```c++
#include<iostream>
#include<string>
using namespace std;
int N;
string str;
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        int c;
        cin>>c;
        string str = to_string(c);
        int  k = str.size() / 2;
        int a = stoi(str.substr(0,k));
        int b = stoi(str.substr(k));
        if(a*b == 0)
        {
            cout<<"No\n";
        }
        else 
        {
            cout<<(c % (a*b) == 0 ? "Yes\n" : "No\n");
        }    
    }
    return 0;
}
```

### **1128** **N Queens Puzzle**

考点：N皇后问题，数组

总结：是否在同一行或者斜着的方向

```c++
#include<iostream>
#include<cmath>
using namespace std;
int  k,n;
int row[1005];
int main()
{
    cin>>k;
    for(int i = 0;i < k;++i)
    {
        cin>>n;
        bool result  = true;
        for(int j = 0;j < n;++j)
        {
            cin>>row[j];
            for(int t = 0;t < j;++t)
            {
                if(row[t] == row[j] || abs(row[t] - row[j]) == (j - t))
                {
                    result = false;
                    break;
                }
            }
        }
        cout<<(result ? "YES\n" : "NO\n");
    }
    return 0;
}
```

### **1124** **Raffle for Weibo Followers**

考点：模拟题

总结：利用continue忽略获奖者。注意处理第一个获奖者。理解 the skip number of winners（获奖者步数）

```c++
#include<iostream>
#include<string>
#include<algorithm>
#include<set>
using namespace std;
set<string> pro;
int main()
{
    int M,N,S;
    cin>>M>>N>>S;
    int ans = 1,cnt = 0;
    for(int i = 0;i < M;++i)
    {
        string name;
        cin>>name;
        if(pro.count(name))
            continue;
        if((ans == S && cnt == 0)||(ans == N && cnt != 0))
        {
            cout<<name<<endl;
            pro.insert(name);
            ans = 0;
            ++cnt;
        }
        ++ans;
    }
    if(cnt == 0)
        cout<<"Keep going...\n";
    return 0;
}
```

### **1120** **Friend Numbers**

考点：字符串，数字

总结：

```c++
#include<iostream>
#include<set>
#include<string>
using namespace std;
int N,cnt;
set<int> st;
int getFriedId(string str)
{
    int sum = 0;
    for(auto &c : str)
    {
        sum += (c - '0');
    }
    return sum;
}
int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        string str;
        cin>>str;
        st.insert(getFriedId(str));
    }
    cnt = st.size();
    cout<<cnt<<endl;
    cnt = 0;
    for(auto &i : st)
    {
        cout<<(cnt++ != 0 ? " " : "")<<i;
    }
    return 0;
}
```

### **1116** **Come on! Let's C** 

考点：素数，数组，字符串，键值

总结：

```c++
#include<iostream>
#include<string>
#include<set>
#include<map>
#include<cmath>
using namespace std;
int N,K;
map<string,string> awardlist;
set<string> list;
bool isPrime(int x)
{
    for(int i = 2;i <= sqrt(x);++i)
    {
        if(x % i == 0)
            return false;
    }
    return true;
}
int main()
{
    cin>>N;
    for(int i = 1;i <= N;++i)
    {
        string name;
        cin>>name;
        list.insert(name);
        awardlist[name] = "Chocolate";
        if(isPrime(i))
            awardlist[name] = "Minion";
        if(i == 1)
            awardlist[name] = "Mystery Award";
    }
    cin>>K;
    for(int i = 0;i < K;++i)
    {
        string id;
        cin>>id;
        if(!list.count(id))
        {
            cout<<id<<": "<<"Are you kidding?\n";
        }
        else 
        {
            cout<<id<<": "<<awardlist[id]<<endl;
            awardlist[id] = "Checked";
        }
    }
    return 0;
}
```

### **1112** **Stucked Keyboard** 

考点：字符串，重复字符

总结：对坏掉的键输入进行处理，坏键会将单个字符重复输出固定的数目，而对于好键对应的字符连续时数目不固定。再处理给定字符串的过程中，可以在边界添加多余字符来处理特殊情况。

```c++
#include<iostream>
#include<string>
#include<set>
#include<map>
using namespace std;
map<char,bool> m;
set<char> st;
map<char,bool> iskey;
int main()
{
    int k;
    cin>>k;
    string str;
    cin>>str;
    char c = '#';
    str += c;
    int cnt = 1;
    for(int i = 0;i < str.size();++i)
    {
        if(c == str[i])
        {
            ++cnt;
        }
        else 
        {
            if(cnt % k != 0)
                iskey[c] = true;//一定是好键盘(不是对应的固定值)
            cnt = 1;
        }
        //难点
        if(i != str.size() - 1)  
            m[str[i]]  = (cnt % k == 0);//可能坏（还要判断重复时长度是否不等于k的倍数）
        c = str[i];
    }
    for(int i = 0;i < str.size() - 1;++i)
    {
        if(iskey[str[i]] == true)//确定坏键盘
        {
            m[str[i]] = false;//之前好的一定不坏
        }
    }
    for(int i = 0;i < str.size() - 1;++i)
    {
        if(m[str[i]]&&!st.count(str[i]))
        {
            cout<<str[i];
            st.insert(str[i]);
        }
    }
    cout<<endl;
    for(int i = 0;i < str.size() - 1;++i)
    {
        cout<<str[i];
        if(m[str[i]])
            i += k - 1;
    }
    return 0;
}
```

### **1108** **Finding Average**

考点：字符串

总结：

**sscanf() – 从一个字符串中读进与指定格式相符的数据**

**sprintf() – 字符串格式化命令，主要功能是把格式化的数据写入某个字符串中**

输出格式问题：注意英文中的单复数形式

```c++
#include<iostream>
#include<string>
#include<cmath>
#include<cstring>
using namespace std;
int main()
{
    string a;
    char b[50];
    int N,ans = 0;
    cin>>N;
    double temp = 0,sum = 0;
    for(int i = 0;i < N;++i)
    {
        cin>>a;
        sscanf(a.c_str(),"%lf",&temp);//以%lf的形式存入temp
        sprintf(b,"%.2f",temp);//以%.2f输出到b
        int flag = 0;
        for(int j = 0;j < a.size();++j)
        {
            if(a[j] != b[j])
            {
                flag = 1;
                break;
            }
        }
        if(flag || temp < -1000 || temp > 1000)
        {
            cout<<"ERROR: "<<a<<" is not a legal number\n";
        }
        else 
        {
            sum += temp;
            ++ans;
        }
    }
    if(ans == 0)
    {
        cout<<"The average of "<<ans<<" numbers is Undefined\n";
    }
    else 
    {
        double ave = sum/ans;
        cout<<"The average of "<<ans<<" number"<<(ans == 1 ? "" : "s")<<" is ";
        printf("%.2f\n",ave);
    }
    return 0;
}
```



考点：

总结：**将数列中的每个数字读取到temp中，假设我们选取的片段中包括temp，且这个片段的首尾指针分别为p和q，那么对于p，有i种选择，即12…i，对于q，有n-i+1种选择，即i, i+1, … n，所以p和q组合形成的首尾片段有i \* (n-i+1)种，因为每个里面都会出现temp，所以temp引起的总和为temp \* i \* (n – i + 1)；遍历完所有数字，将每个temp引起的总和都累加到sum中，最后输出sum的值～**

```c++
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin>>n;
    long long sum = 0;
    for(int i = 0;i < n;++i)
    {
        double  x;
        cin>>x;
        sum += (long long)(x * 1000) * (i + 1) * (n - i);//防止精确度丢失
    }
    printf("%.2f\n",sum/1000.0);
    return 0;
}
```

### **1001** **A+B Format**

考点：字符串，取余

总结：输出数字的时候要判断该数字位数是否为3的倍数，是3的倍数需要在其前面加一个分隔符（确保不是最高位)

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int a,b;
    string sum;
    cin>>a>>b;
    a += b;
    if(a < 0)
    {
        cout<<"-";
        a = 0 - a;
    }
    sum = to_string(a);
    int len = int(sum.size());
    cout<<sum[0];
    for(int i = 1;i < len;++i)
    {
        if((len - i)% 3 ==0)
            cout<<",";
        cout<<sum[i];
    }
    cout<<"\n";
    return 0;
}
```

### **1005** **Spell It Right**

考点：字符串

总结：

```c++
#include<iostream>
#include<string>
#include<vector>
using namespace std;
vector<string> a = {"zero","one","two","three","four","five","six","seven","eight","nine"};
int main()
{
    string str;
    cin>>str;
    int sum = 0;
    for(auto &c : str)
    {
        sum += (c - '0');
    }
    string test = to_string(sum);
    cout<<a[(test[0] - '0')];
    for(int i = 1;i < test.size();++i)
    {
        cout<<" "<<a[(test[i] - '0')];
    }
    cout<<endl;
    return 0;
}
```

### **1002** **A+B for Polynomials** 

考点：运算，数组

总结：

总结：

```ruby
#include<iostream>
#include<math.h>
using namespace std;
double c1[1005],c2[1005];
int t1  = -1,t2 = -1;
int main()
{
    int n;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        int e;
        double co;
        cin>>e>>co;
        if(t1 == -1)
            t1 = e;
        c1[e] = co;
    }
    cin>>n;

    for(int i = 0;i < n;++i)
    {
        int e;
        double co;
        cin>>e>>co;
        if(t2 == -1)
        {
            t2 = e;
        }
        c2[e] = co;
    }
    int max_e = max(t1,t2);
    for(int i = 0;i <= max_e;++i)
    {
        c1[i] += c2[i];
    }
    int cnt = 0;
    for(int i = max_e ; i >= 0;--i)
    {
        if(abs(c1[i]) + 0.05 >= 0.1)
            ++cnt;
    }
    cout<<cnt;
    for(int i = max_e; i >= 0;--i)
    {
        if(abs(c1[i]) + 0.05 >= 0.1)
        {

            printf(" %d %.1f",i,c1[i]);
            cnt--;
            if(cnt == 0)
                break;
        }
    }
    return 0;
}
//C:\\mingw64\\bin\\g++.exe
```

### **1003** **Emergency** 

> 考点：迪杰斯特拉算法
>
> 总结：最短路径有几条，召集最多的救援队

```ruby
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
using pii = pair<int,int>;
struct edge
{
    int to,cost;
};
vector<int> dis,Rc,pre;
vector<vector<edge> > G;
vector<int> totalRescue,Rescue;
int N,M,c1,c2;
void Dijkstra()
{
    dis = vector<int>(N,0x3f3f3f3f);
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    Rc[c1] = 1;
    dis[c1] = 0;
    totalRescue[c1] = Rescue[c1];
    pq.push({dis[c1],c1});

    while(!pq.empty())
    {
        auto v = pq.top();
        pq.pop();

        int x = v.second;
        if(dis[x] < v.first)
            continue;
        
        for(auto &e : G[x])
        {
            if(dis[e.to] > dis[x] + e.cost)
            {
                Rc[e.to] = Rc[x];
                totalRescue[e.to] = totalRescue[x] + Rescue[e.to];
                dis[e.to] = dis[x] + e.cost;
                pre[e.to] = x;

                pq.push({dis[e.to],e.to});
            }
            else if(dis[e.to] == dis[x] + e.cost)
            {
                Rc[e.to] += Rc[x];
                if(totalRescue[e.to] < totalRescue[x] + Rescue[e.to])
                {
                    pre[e.to] = x;
                    totalRescue[e.to] = totalRescue[x] + Rescue[e.to];
                }
            }
        }
    }
}
int main()
{
    cin>>N>>M>>c1>>c2;
    G.resize(N);
    pre.resize(N);
    totalRescue.resize(N);
    Rescue.resize(N);
    Rc.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>Rescue[i];
    }
    for(int i = 0;i < M;++i)
    {
        int x,y,z;
        cin>>x>>y>>z;
        G[x].push_back({y,z});
        G[y].push_back({x,z});
    }
    Dijkstra();
    cout<<Rc[c2]<<" "<<totalRescue[c2]<<endl;
    return 0;
}
```

### **1006** **Sign In and Sign Out** 

> 考点：排序
>
> 总结：

```ruby
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
using pii = pair<string,int>;
vector<pii> inl,outl;
bool cmp(pii &e1,pii &e2)
{
    return e1.second < e2.second;
}
int n;
int main()
{
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        string str;
        cin>>str;
        int a1,a2,a3,b1,b2,b3;
        scanf("%d:%d:%d",&a1,&a2,&a3);
        scanf("%d:%d:%d",&b1,&b2,&b3);
        a1 = a1 * 60 * 60 + a2 * 60 + a3;
        b1 = b1 * 60 * 60 + b2 * 60 + b3;
        inl.push_back({str,a1});
        outl.push_back({str,b1});
    }
    sort(inl.begin(),inl.end(),cmp);
    sort(outl.begin(),outl.end(),cmp);
    cout<<inl[0].first<<" "<<outl.back().first<<endl;

    return 0;
}
```

#### **1018** **Public Bike Management** 

考点：Dijkstra算法，dfs算法

总结：读懂题目意思，最短路，并且携带的自行车最少

```ruby
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
using pii = pair<int,int>;
struct edge
{
    int to,cost;
};
vector<vector<int> > pre;
vector<int> path,tempPath;
vector<int> weight,dis;
vector<vector<edge> > G;
int Cmax,N,Sp,M,result_need = 1<<30,result_back = 1<<30;
void dfs(int x)
{   
    tempPath.push_back(x);
    if(x == 0)
    {
        int need = 0,back = 0;
        int l = int(tempPath.size());
        for(int i = l - 1;i >= 0; --i)
        {
            int id = tempPath[i];
            if(weight[id] > 0)
            {
                back += weight[id];
            }
            else 
            {
                if(back > (0 - weight[id]))
                {
                    back += weight[id];
                }
                else 
                {
                    need += ((0 - weight[id]) - back);
                    back = 0;
                }
            }
        }

        if(need < result_need)
        {
            result_need = need;
            result_back = back;

            path = tempPath;
        }
        else if(need == result_need && back < result_back)
        {
            result_back = back;
            path = tempPath;
        }
        tempPath.pop_back();
        return ;
    }

    for(auto &e : pre[x])
    {
        dfs(e);
    }


    tempPath.pop_back();
}
void Dijkstra()
{
    dis = vector<int>(N+1,0x3f3f3f3f);
    dis[0] = 0;
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    pq.push({dis[0],0});

    while(!pq.empty())
    {
        auto v = pq.top();
        pq.pop();

        int x = v.second;
        if(dis[x] < v.first)
            continue;
        
        for(auto &e : G[x])
        {
            if(dis[e.to] > dis[x] + e.cost)
            {
                dis[e.to] = dis[x] + e.cost;

                pre[e.to].clear();
                pre[e.to].push_back(x);

                pq.push({dis[e.to],e.to});
            }
            else if(dis[e.to] == dis[x] + e.cost)
            {
                pre[e.to].push_back(x);
            }
        }
    }
}
int main()
{   
    cin>>Cmax>>N>>Sp>>M;
    pre.resize(N+1);
    weight.resize(N+1);
    G.resize(N+1);

    for(int i = 1;i <= N;++i)
    {
        int num;
        cin>>num;
        weight[i] = num - Cmax/2;
    }

    for(int i = 0;i < M;++i)
    {
        int f,t,c;
        cin>>f>>t>>c;
        G[f].push_back({t,c});
        G[t].push_back({f,c});
    }
    Dijkstra();
    
    dfs(Sp);
    cout<<result_need;
    cout<<" 0";
    for(int i = path.size() - 2;i >= 0;--i)
    {
        cout<<"->"<<path[i];
    }
    cout<<" "<<result_back<<endl;
    return 0;
}
```

#### **1022** **Digital Library**

考点：Hash函数

总结：给定键值查找id，利用set集合按序输出

```ruby
#include<iostream>
#include<string>
#include<set>
#include<map>
using namespace std;
int N,M;
map<string,set<string> > sm;
map<string,set<string> > keys;
int main()
{
    cin>>N;
    getchar();
    for(int i = 0;i < N;++i)
    {
        string id;
        getline(cin,id);
        sm[id].insert(id);
        for(int j = 0;j < 5;++j)
        {

            string ct;
            getline(cin,ct);

            sm[ct].insert(id);

            if(j == 2)
            {
                int sp = 0;
                ct.push_back(' ');
                for(int d = 0;d < ct.size();++d)
                {
                    if(ct[d] == ' ')
                    {
                        string kid = ct.substr(sp,d - sp);
                        keys[kid].insert(id);
                        sp = d + 1;
                    }
                }
            }
        }
    }
    cin>>M;
    getchar();
    for(int i = 0;i < M;++i)
    {
        string testStr;
        getline(cin,testStr);
        cout<<testStr<<endl;
        testStr = testStr.substr(3);
        if(!sm.count(testStr))
        {
            if(!keys.count(testStr))
            {
                cout<<"Not Found\n";
            }
            else 
            {
                for(auto &id : keys[testStr])
                {
                    cout<<id<<endl;
                }
            }
        }
        else 
        {
            
                for(auto &id : sm[testStr])
                {
                       cout<<id<<endl;
                }
            
        }
    }
    return 0;
}
```

### **1026** **Table Tennis** 

> 考点：排队
>
> 总结：送客，入队，迎客（优先考虑会员）

```ruby
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
struct player
{
    int come_time,play_time,serve_time = 0,leave_time;
    int isvip = 0;
};
struct table
{
    int count = 0,serve = -1;//-1表示闲置
    int isvip = 0;
};
player p[10000];
table t[101];
vector<int> v;
bool comp(player x,player y)
{
    return x.come_time < y.come_time;
}
void printtime(int Time)
{
    printf("%02d:%02d:%02d ",Time/3600,Time%3600/60,Time%60);
}
int main()
{
    int N,K,M,i,j;//N个人，K个桌子，M会员桌子
    cin>>N;
    for(i = 0;i < N;++i)
    {
        int hh,mm,ss;
        char c;
        cin>>hh>>c>>mm>>c>>ss>>p[i].play_time>>p[i].isvip;
        p[i].come_time = hh * 3600 + mm * 60 + ss;
        p[i].play_time *= 60;
        if(p[i].play_time  > 7200)
            p[i].play_time = 7200;   
    }
    cin>>K>>M;
    while(M--)
    {
        cin>>i;
        t[i].isvip = 1;
    }
    sort(p,p + N,comp);
    queue<int> q1,q2;//1 普通队列 ， 2 会员队列
    int cursor = 0;
    for(int Time = 28800; Time < 75600;Time++)
    {
        for(i = 1;i <= K;++i)
        {
            if(t[i].serve >= 0)
            {
                j = t[i].serve;

                if(p[j].leave_time == Time)//可以走了
                {
                    t[i].serve = -1;
                }
            }
        }
        //送客
        while(cursor < N && p[cursor].come_time == Time)
        {
            q1.push(cursor);
            if(p[cursor].isvip)
            {
                q2.push(cursor);
            }
            cursor++;
        }
        //入队
        while(q2.size()&&p[q2.front()].serve_time != 0)//过滤有桌子的
        {
            q2.pop();
        }
        for(i = 1;i <= K;++i)
        {
            if(!t[i].isvip)//留下会员的桌子
            {
                continue;
            }
            if(t[i].serve < 0)//
            {
                if(q2.size())
                {
                    j = q2.front();
                    v.push_back(j);
                    t[i].serve = j;
                    t[i].count++;
                    p[j].serve_time = Time;
                    p[j].leave_time = Time + p[j].play_time;
                    while(q2.size()&& p[q2.front()].serve_time != 0)
                    {
                        q2.pop();
                    }
                }
            }
        }   
        while(q1.size()&&p[q1.front()].serve_time != 0)
        {
            q1.pop();
        }
        for(i = 1;i <= K;i++)
        {
            if(t[i].serve < 0)
            {
                if(q1.size())
                {
                    j = q1.front();
                    v.push_back(j);
                    t[i].serve = j;
                    t[i].count++;
                    p[j].serve_time = Time;
                    p[j].leave_time = Time + p[j].play_time;
                    while(q1.size()&&p[q1.front()].serve_time != 0)
                    {
                        q1.pop();
                    }
                }
            }
        }
        //迎客
    }
    for(auto &e : v)
    {
        printtime(p[e].come_time);
        printtime(p[e].serve_time);
        cout<<(p[e].serve_time - p[e].come_time + 30)/60<<endl;
    }
    for(int i = 1;i <= K;++i)
    {
        cout<<t[i].count<<(i != K ? " " : "\n");
    } 
    return 0;
}
```

### **1028** **List Sorting**

> 考点：排序
>
> 总结：根据数组中对应的内容排序

```ruby
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
int N,C;
struct node
{
    string mes[3];
    bool operator<(const node &e)const
    {
        if(mes[C] != e.mes[C])
        {
            return mes[C] < e.mes[C];
        }
        else 
        {
            return mes[0] < e.mes[0];
        }

    }
};
vector<node> peo;
int main()
{
    cin>>N>>C;
    C--;
    for(int i = 0;i < N;++i)
    {
        string id,name,grade;
        cin>>id>>name>>grade;
        peo.push_back({id,name,grade});
    }
    sort(peo.begin(),peo.end());
    for(auto &e : peo)
    {
        cout<<e.mes[0]<<" "<<e.mes[1]<<" "<<e.mes[2]<<endl;
    }
    return 0;
}
```

#### **1029** **Median**

> 考点：排序
>
> 总结：也可以用二分查找

```ruby
#include<iostream>
#include<vector>
#include<cmath>
#include<limits.h>
#include<algorithm>
using namespace std;
vector<int> v1,v2;
int main()
{
    int n,m;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
       int x;
        cin>>x;
        v1.push_back(x);
    }
    cin>>m;
    for(int i = 0;i < m;++i)
    {
        int x;
        cin>>x;
        v2.push_back(x);
    }
    int target = ( n + m + 1)/2;
    int i = 0,j = 0,cnt = 0,ans = 0;
    while(i < n && j < m)
    {
        ans = (v1[i] <= v2[j] ? v1[i++] : v2[j++]);
        if(++cnt == target)
            break;
    }
    while(i < n && cnt < target)
    {
        ans = v1[i++];
        ++cnt;
    }
    while(j < m && cnt < target)
    {
        ans = v2[j++];
        ++cnt;
    }
    cout<<ans<<endl;
    return 0;
}
```

#### **1030** **Travel Plan**

> 考点：Dijkstra算法
>
> 总结：

```ruby
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
using pii = pair<int,int>;
struct edge
{
    int to,l,c;
};
vector<int> totalC;
vector<int> pre;
vector<int> dis;
vector<vector<edge> > G;
int N,M,S,D;
void Dijkstra()
{
    dis = vector<int>(N,0x3f3f3f3f);
    dis[S] = 0;
    priority_queue<pii,vector<pii>,greater<pii> > pq;
    pq.push({dis[S],S});
    pre[S] = -1;
    totalC[S] = 0;
    while(!pq.empty())
    {
        auto v = pq.top();
        pq.pop();
        int x = v.second;
        if(dis[x] < v.first)
            continue;
        for(auto &e : G[x])
        {
            if(dis[e.to] > dis[x] + e.l)
            {
                dis[e.to] = dis[x] + e.l;
                pre[e.to] = x;
                totalC[e.to] = totalC[x] + e.c;
                pq.push({dis[e.to],e.to});
            }
            else if(dis[e.to] == dis[x] + e.l)
            {
                if(totalC[e.to]  > totalC[x] + e.c)
                {
                    pre[e.to] = x;
                    totalC[e.to] = totalC[x] + e.c;
                }
            }
        }
    }
}
void printPath(int x)
{
    if(pre[x] == -1)
    {
        cout<<x;
        return;
    }
    printPath(pre[x]);
    cout<<" "<<x;
}
int main()
{
    cin>>N>>M>>S>>D;
    G.resize(N);
    pre.resize(N);
    totalC.resize(N);
    for(int i = 0;i < M;++i)
    {
        int x,y,l,c;
        cin>>x>>y>>l>>c;
        G[x].push_back({y,l,c});
        G[y].push_back({x,l,c});
    }
    Dijkstra();
    printPath(D);
    cout<<" "<<dis[D]<<" "<<totalC[D]<<endl;
    return 0;
}
```

### **1032** **Sharing** 

***

> 总结：链表遍历
>
> 考点：链表

```ruby
#include<iostream>
using namespace std;
const  int max_n = 1000005;
struct node
{
    int key;
    int next;
    bool flag = false;
};
node na[max_n];
int N,firstH,secondH;
int main()
{
    cin>>firstH>>secondH>>N;
    for(int i = 0;i < N;++i)
    {
        int address,nextaddress;
        char c;
        cin>>address>>c>>nextaddress;
        na[address].key = c;
        na[address].next = nextaddress;
    }
    for(;firstH != -1;firstH = na[firstH].next)
    {
        na[firstH].flag = true;
    }
    for(;secondH != -1;secondH = na[secondH].next)
    {
        if(na[secondH].flag == true)
        {
            printf("%05d",secondH);
            return 0;
        }
    }
    cout<<"-1\n";
    return 0;
}
```

### **1033** **To Fill or Not to Fill** 

> 考点：贪心
>
> 总结：注意油量是否加满（加满或者加到刚刚到达某站）

```ruby
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct station{
    double price;
    double distance;
};
double CMAX,D,Davg;
int N;
bool cmp(station &n1,station &n2)
{
    return n1.distance < n2.distance;
}
int main()
{
    cin>>CMAX>>D>>Davg>>N;
    vector<station> st(N+1);
    st[0] = {0.0,D};//目的地

    for(int i = 1;i <= N;++i)
    {
        cin>>st[i].price>>st[i].distance;
    }
    sort(st.begin(),st.end(),cmp);
    if(st[0].distance != 0)
    {
        cout<<"The maximum travel distance = 0.0";
        return 0;
    }
    double nowprice = st[0].price,nowdis = 0,maxdis = 0,leftdis = 0,totalPrice = 0;
    while(nowdis < D)
    {
        maxdis = nowdis + CMAX * Davg;
        double minPrice = 0x3f3f3f3f,minDis = 0;//找到前方汽油站的价格最小的 和 位置
        bool flag = false;

        for(int  i = 1;i <= N && st[i].distance  <= maxdis;++i)
        {
            if(st[i].distance <= nowdis)
                continue;

            if(st[i].price < nowprice)//把汽油加到刚刚到达那里
            {
                //汽油加到刚刚到达那里， （减去此时的距离和剩余汽油所能走的距离）
                totalPrice += ((st[i].distance - nowdis - leftdis)/Davg)*nowprice;
                leftdis = 0;
                nowdis = st[i].distance;
                nowprice = st[i].price;
                flag = true;
                break;
            }

            //找最小的价格
            if(minPrice > st[i].price)
            {
                minDis = st[i].distance;
                minPrice = st[i].price;
            }
        }
        ///找到最小的价格 但是 比当前的要大 则加满之后再去那里
        //找不到比当前价格小的；1 找最小的 如果找不到最小的即到不了第一个站
        if(flag == false && minPrice != 0x3f3f3f3f)
        {
            //加了多少汽油（此时应当把汽油加满）：最大容量 减去 剩余油量
            totalPrice += (CMAX - leftdis/Davg)*nowprice;
            //到到这里的时候 剩余多少汽油
            leftdis = (CMAX*Davg - (minDis - nowdis));

            nowdis = minDis;
            nowprice = minPrice;
        }
        //到不了下一个加油站
        if(flag == false && minPrice == 0x3f3f3f3f)
        {//说明到达下一站的汽油不够了
            double sum = Davg * CMAX + nowdis;
            printf("The maximum travel distance = %.2f",sum);
            return 0;
        }

    }
    printf("%.2f",totalPrice);
    return 0;
}
```

> 方法二

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
typedef struct gas
{
    double pric,dis;//汽油站的结构体：距离和价格
}Gas;
bool cmp(Gas a,Gas b) //按照距离顺序排序
{
    return a.dis < b.dis;
}
int main()
{
    double c,ds,dv;
    int n;
    cin>>c>>ds>>dv>>n;
    vector<Gas> v(n+1);
    for(int i = 0;i < n;++i)
    {
        cin>>v[i].pric>>v[i].dis;
    }
    v[n].pric = 0;//将目的地作为一个价格为0的加油站
    v[n].dis = ds;
    sort(v.begin(),v.end(),cmp);
    if(v[0].dis != 0)
    {
        printf("The maximum travel distance = 0.00");
        return 0;
    }
    double tank = 0,maxd = c * dv, sum = 0;//tank表示当前邮箱存储量，maxd表示满邮箱的最远距离
    int now = 0;//now表示现在的站点
    while(1)
    {
        int next = -1;//next表示下一站
        double min = 0x3f3f3f3f; //记录下一站的最低价格
        for(int i = now + 1;i <= n && v[now].dis + maxd >= v[i].dis;i++)//在满邮箱能到达的范围内寻找价格
        {
            if(v[i].pric < min)
            {
                min = v[i].pric;
                next = i;
                if(min < v[now].pric)//如果最低价格低于当前价格，则直接去这个
                {
                    break;
                }
            }
        }
        if(next == -1)//如果下一站不可到达，终止并输出
        {
            printf("The maximum travel distance = %.2f",v[now].dis + maxd);
            break;
        }
        double need = (v[next].dis - v[now].dis)/dv; //need表示当前站到下一站的距离所需要的油
        if(min < v[now].pric)//如果下一站的价格低于当前，则只要能到下一站
        {
            if(tank < need)
            {
                sum += (need - tank)*v[now].pric;
                tank = 0;//更新到下一站时候的剩余量
            }
            else 
            {
                tank -= need;//如果不需要加油，直接去
            }
        }
        else
        {
            sum += (c - tank)*v[now].pric;//如果下一站比较贵，在这一站直接加满
            tank = c - need;
        }
        
        now = next;//更新当前站
        if(next == n)//如果下一站是终点，则输出结果，停止循环
        {
            printf("%.2f",sum);
            break;
        }
    }
    return 0;
}
```

### **1036** **Boys vs Girls**

> 考点：排序
>
> 总结：找最高分的女生和最低分的男生

```ruby
#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
    string fmale,male;
    int n;
    int minM = 101,maxF = -1;
    cin>>n;
    for(int i = 0;i < n;++i)
    {
        string name,gender,id,grade;
        cin>>name>>gender>>id>>grade;
        if(gender == "F")
        {
            if(stoi(grade) > maxF)
            {
                maxF = stoi(grade);
                fmale = name + " " + id + "\n";
            }
        }
        else 
        {
            if(stoi(grade) < minM)
            {
                minM = stoi(grade);
                male = name + " " + id + "\n";
            }
        }
    }

    if(maxF != -1)
    {
        cout<<fmale;
    }
    else 
    {
        cout<<"Absent\n";
    }

    if(minM != 101)
    {
        cout<<male;
    }
    else 
    {
        cout<<"Absent\n";
    }
    if(minM != 101 && maxF != -1)
    {
        cout<<abs(minM - maxF);
    }
    else 
    {
        cout<<"NA";
    }
    return 0;
}
```

### **1153** **Decode Registration Card of PAT**

> 考点：排序，超时问题
>
> 总结：使用scanf ，printf 要比cin ，cout 速度快，在输入样例的过程中尽量减少定义变量的次数（也就是把输入要用到的变量一次声明完成）。string可以利用 `c_str`转换成字符数组用`printf`输出。`unorder_map`要比`map`容器快，省略的排序操作。

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<unordered_map>
#include<algorithm>
using namespace std;
int N,M;
struct node
{
    int value;
    string id;
};
bool cmp(const node &e1,const node &e2) 
{
    if(e1.value != e2.value)
    {
        return e1.value > e2.value;
    }
    else 
    {
        return e1.id  < e2.id;
    }
}
vector<node> list;
int main()
{
    //首先声明传递参数的定义变量：省略了重复创建次数减少时间，
        int x;
        string ctr;
    
    cin>>N>>M;
    list.resize(N);
    for(int i = 0;i < N;++i)
    {
        cin>>list[i].id>>list[i].value;
    }
    for(int i = 1;i <= M;++i)
    {
      
        cin>>x>>ctr;
        cout<<"Case "<<i<<": "<<x<<" "<<ctr<<endl;
        vector<node> ans;
        if(x == 1)
        {
            for(auto &e : list)
            {
                if(e.id[0] == ctr[0])
                {
                   ans.push_back({e.value,e.id}); 
                }
            }
        }
        else if(x == 2)
        {
            int sum = 0,cnt = 0;
            for(auto &e : list)
            {
               
                if(e.id.substr(1,3) == ctr)
                {
                    sum += e.value;
                    ++cnt;
                }
            }
            if(cnt != 0)
            {
                printf("%d %d\n",cnt,sum);
                continue;
            }
            else 
            {
                printf("NA\n");
                continue;
            }
        }
        else if(x == 3)
        {
            unordered_map<string,int> ms;
            for(auto &e :list)
            {    
                if(e.id.substr(4,6) == ctr)
                {
                    ms[e.id.substr(1,3)]++;
                }
            }
            for(auto &w : ms)
            {
                ans.push_back({w.second,w.first});
            }
        }
        sort(ans.begin(),ans.end(),cmp);
        if(ans.size() == 0)
        {
            cout<<"NA\n";
        }
        else 
        {  
            for(auto &result : ans)
            {
                printf("%s %d\n",result.id.c_str(),result.value);
            }
        }
    }
    return 0;
}
```

### **1150** **Travelling Salesman Problem** **

> 考点：图的存储（这里用邻接矩阵比较方便），理解
>
> 总结：对于遍历每个城市的理解（一种是每个城市走一遍，另一种是循环过程中除了起点外，其他城市出现路过多次）

```ruby
#include<iostream>
#include<vector>
#include<set>
using namespace std;
int N,M,K;
int edge[210][210]={0};
int ans = 1<<30,dissum = 1<<30;
void check(int index)
{
    int cnt;
    cin>>cnt;
    vector<int> v(cnt);
    set<int> st;
    for(int i = 0;i < cnt;++i)
    {
        cin>>v[i];
        st.insert(v[i]);
    }
    bool flag = 1;
    int sum = 0;
    //是否是循环，简单循环，普通循环，不是循环 （输出总的距离）
    for(int i = 0;i < cnt - 1;++i)
    {
        if(edge[v[i]][v[i+1]] == 0)
        {
            flag = 0;
        }
        sum += edge[v[i]][v[i+1]];
    }
    //不存在这种路径
    if(flag == 0)
    {
        printf("Path %d: NA (Not a TS cycle)\n",index);
    }
    else if(v[0] != v[cnt - 1] || st.size() != N)//不是游览每个城市的循环
    {
        printf("Path %d: %d (Not a TS cycle)\n",index,sum);
    }
    else if(cnt != N + 1)//虽然遍历每一个城市，但是有城市走了多次（最佳路径是每个城市只走一次）
    {
        printf("Path %d: %d (TS cycle)\n",index,sum);
        //cout<<"----------n every  cnt != n + 1---------"<<st.size()<<"n --"<<N<<"----\n";
        /*for(int i = 0;i < cnt;++i)
        {
            cout<<v[i]<<' ';
        }
        cout<<endl;*/
        if(ans > sum)
        {
            ans = sum;
            dissum = index;
        }
    }
    else 
    {
        printf("Path %d: %d (TS simple cycle)\n",index,sum);
        if(ans > sum)
        {
            ans = sum;
            dissum = index;
        }
    }
}
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y,z;
        cin>>x>>y>>z;
        edge[x][y] = edge[y][x] = z;
    }
    cin>>K;
    for(int i = 1;i <= K;++i)
    {
        check(i);
    }
    printf("Shortest Dist(%d) = %d\n",dissum,ans);
    return 0;
}
```

### **1149** **Dangerous Goods Packaging** 

> 考点：容器
>
> 总结：存储每个商品不能共存的商品，遍历每个测试数组，查询每个商品不共存的集合中是否存在在测试数据中（这里用数组cnt标记测试的商品，如果集合中存在测试数据，这组测试就不能通过）。

```ruby
#include<iostream>
#include<unordered_map>
#include<vector>
using namespace std;
int N,M,K;
unordered_map<int,vector<int> > ms;
int main()
{ 
    cin>>N>>M;
    for(int i = 0;i < N;++i)
    {
        int a,b;
        cin>>a>>b;
        ms[a].push_back(b);
        ms[b].push_back(a);
    }
    for(int i = 0;i < M;++i)
    {
        cin>>K;
        int a[100000] = {0};
        vector<int> cnt(K);
        for(int j = 0;j < K;++j)
        {
            cin>>cnt[j];
            a[cnt[j]] = 1;
        }
        bool flag = 1;
        for(int j = 0;j < K;++j)
        {
            for(int d = 0;d < ms[cnt[j]].size();++d)
            {
                if(a[ms[cnt[j]][d]] == 1)
                {
                    flag = 0;
                    break;
                }
            }
        }
        cout<<(flag == 1 ? "Yes\n": "No\n");
    }
    return 0;
}
```

### **1146** **Topological Order** 

> 考点：拓扑排序，图的存储，入度
>
> 总结：

```ruby
#include<iostream>
#include<vector>
using namespace std;
int N,M,K;
vector<vector<int> > G;
vector<int> inr;
int main()
{
    cin>>N>>M;
    G.resize(N+1);
    inr.resize(N+1);
    for(int i = 0;i < M;++i)
    {
        int  x,y;
        cin>>x>>y;
        G[x].push_back(y);
        inr[y]++;
    }
    cin>>K;
    vector<int> ans;
    for(int i = 0;i < K;++i)
    {
        int a;
        bool judge = 1;
        vector<int> intest(inr.begin(),inr.end());
        for(int j = 0;j < N;++j)
        {   
            scanf("%d",&a);
            if(intest[a] != 0)
            {
                judge = 0;
            }
            for(auto &w : G[a])
            {
                intest[w]--;
            }
        }
        if(judge == 1)
        {
            continue;
        }
        ans.push_back(i);
    }
    bool flag = 0;
    for(auto w : ans)
    {
        printf("%s%d",(flag == 1 ? " " : ""),w);
        flag = 1;
    }
    return 0;
}
```

### **1145** **Hashing - Average Search Time** 

> 考点：hash函数：平方探测
>
> 总结：插入时下标从0 到 size - 1	 ，查找时下标为0 到 size  。有问题

```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int N,M,Msize,a;
int v[100005] = {0};
bool isPrime(int x)
{
    for(int i = 2;i <= sqrt(x);++i)
    {
        if(x % i == 0)
        {
            return false;
        }
    }
    return true;
}
int main()
{
    scanf("%d %d %d",&Msize,&N,&M);
    while(!isPrime(Msize))
    {
        Msize++;
    }

    for(int i = 0;i < N;++i)
    {
        scanf("%d",&a);
        int flag = 0;
        for(int j = 0;j < Msize;++j)
        {
            int ind = (a + j * j)%Msize;
            if(v[ind] == 0)
            {
                v[ind] = a;
                flag = 1;
                break;
            }
        }
        if(!flag)
            printf("%d cannot be inserted.\n",a);
    }
    int ans = 0;
    for(int i = 0;i < M;++i)
    {
        scanf("%d",&a);
        for(int j = 0;j <= Msize;++j)
        {
            ++ans;
            int ind = (a + j*j)%Msize;
            if(v[ind] == 0 ||v[ind] == a)
                break;
        }
    }
    printf("%.1f\n",(ans*1.0)/M);
    return 0;
}
```

### **1142** **Maximal Clique**

> 考点：图的存储，邻接矩阵
>
> 总结：对于每个测试，利用枚举查找测试数据中是否有不相邻的点，如果都相邻，说明是团。之后对团进行分类（最大，不是最大），方法：首先标记团中的顶点，查找不在团中的顶点，对顶点进行检查，如果存在不在团中的顶点与测试中所有都相邻说明该团不是最大，否则是。

```ruby
#include<iostream>
#include<vector>
#include<unordered_map>
#include<algorithm>
using namespace std;
int N,M,K,Nv,nx;
int edge[220][220] = {0};
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        edge[x][y] = edge[y][x] = 1;
    }
    cin>>K;
    for(int i = 0;i < K;++i)
    {
        cin>>Nv;
        unordered_map<int,int> h;
        vector<int> vs(Nv);
        for(int j = 0;j < Nv;++j)//测试
        {
            cin>>vs[j];
            h[vs[j]] = 1;
        }
        bool adjacent = 1;
        //查找是否是团
        for(int j = 0;j < Nv;++j)
        {
            if(adjacent == 0)break;
            for(int d = j + 1;d < Nv;++d)
            {//测试中有不相邻的
                if(edge[vs[j]][vs[d]] == 0)
                {
                    adjacent = 0;
                    break;
                }
            }
        }
        if(adjacent == 0)
            printf("Not a Clique\n");
        else
        {
            int ans = 0;
            //是团，查看是否为最大
            for(int j = 1;j <= N;++j)//n个顶点
            {
                //查看是否有不相邻
                if(h[j] == 0)
                {
                    int w;
                    for(w = 0;w < vs.size();++w)
                    {
                        if(edge[j][vs[w]] == 0)
                        {
                            break;
                        }
                    }
                    if(w == vs.size())
                        ++ans;
                }
            }
            if(ans)
                printf("Not Maximal\n");
            else 
                 printf("Yes\n");
        }
        
        
    }
    return 0;
}
```

## **1141** **PAT Ranking of Institutions** 

> 考点：排序，计算，排名格式
>
> 总结：学校不区分大小写，tws取整数部分，排名

```ruby
#include<iostream>
#include<vector>
#include<string>
#include<unordered_map>
#include<algorithm>
using namespace std;
int N;
unordered_map<string,int> ScoreA,ScoreB,ScoreT,totalS,TWS,Peo;
struct node
{
    string school;
    int tws;
    int num;
    bool operator<(const node &e)const
    {
        if(tws != e.tws)
        {
            return tws > e.tws;
        }
        else 
        {
            if(num != e.num)
            {
                return num < e.num;
            }
            else 
            {
                return school < e.school;
            }
        }
    }
};
vector<node> ans;
void islowerPro(string &str)
{
    for(int i = 0;i < str.size();++i)
    {
        if(!islower(str[i]))
          str[i] = tolower(str[i]);
    }
}
int main()
{
    scanf("%d",&N);
    for(int i = 0;i < N;++i)
    {
        string sid,School;
        int grade;
       // scanf("%s %d %s",&sid,&grade,&School);
       cin>>sid>>grade>>School;
        islowerPro(School);
      //  cout<<"---School"<<School<<endl;
        //等级
        if(sid[0] == 'A')
        {
            ScoreA[School] += grade;
        }
        else if(sid[0] == 'B')
        {
            ScoreB[School] += grade;
        }
        else if(sid[0] == 'T')
        {
            ScoreT[School] += grade;
        }
        //总分数
        totalS[School] += grade;
        Peo[School]++;
    }
    int sum = 0;
    for(auto &e : Peo)
    {
        sum = ScoreB[e.first]/1.5 + ScoreA[e.first] + ScoreT[e.first]*1.5;
       // cout<<sum<<endl;
        ans.push_back({e.first,sum,Peo[e.first]});
    }
    sort(ans.begin(),ans.end());
    int pre = 1;
    cout<<ans.size()<<endl;
    cout<<pre<<" "<<ans[0].school<<" "<<ans[0].tws<<" "<<ans[0].num<<endl;
    for(int i = 1;i < ans.size();++i)
    {
        if(ans[i].tws == ans[i-1].tws)
        {
            cout<<pre<<" ";
        }
        else 
        {
            cout<<(i+1)<<" ";
            pre = (i+1);
        }
        cout<<ans[i].school<<" "<<ans[i].tws<<" "<<ans[i].num<<endl;
    }
    return 0;
}
```

### **1134** **Vertex Cover**

> 考点：图的存储
>
> 总结：查找图中的所有边是否都有顶点在测试集合中

```ruby
#include<iostream>
#include<vector>
#include<set>
using namespace std;
using pii = pair<int,int>;
int N,M,K,Nv;
vector<pii> ed;
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        if(x > y)
            swap(x,y);
        ed.push_back({x,y});
    }
    cin>>K;
    for(int j = 0;j < K;++j)
    {
        cin>>Nv;
        set<int> v;
        while(Nv--)
        {
            int id;
            cin>>id;
            v.insert(id);
        }
          int ans = 0;
            for(auto &w : ed)
            {
                int nx = w.first,ny = w.second;
                if(v.count(nx)||v.count(ny))
                    ++ans;
            }
            cout<<(ans != M ? "No\n" : "Yes\n");
    }
    return 0;
}
```

### **1133** **Splitting A Linked List** 

> 考点：链表
>
> 总结：按照链表的顺序查找对应类型的数值。各类型按照顺序存入集合，再合并之后输出即可。

```ruby
#include<iostream>
#include<vector>
using namespace std;
const int max_n = 100005;
struct node
{
    int address;
    int data;
    int next;
};
int data[max_n],ntr[max_n];
vector<node> ans;
vector<node> nongit,smallK;
int firstnode,N,K;
int main()
{
    cin>>firstnode>>N>>K;
    for(int i = 0;i < N;++i)
    {
        int f,d,nx;
        cin>>f>>d>>nx;
        data[f] = d;
        ntr[f] = nx;

    }
    while(firstnode != -1)
    {
        int f = firstnode,d = data[f],nx = ntr[f];
        if(d < 0)
        {
            nongit.push_back({f,d,nx});
        }
        else if(d >= 0 && d <= K)
        {
            smallK.push_back({f,d,nx});
        }
        else 
        {
            ans.push_back({f,d,nx});
        }
        firstnode = nx;
    }
    for(auto &w : smallK)
    {
        nongit.push_back(w);
    }
    for(auto &w : ans)
    {
        nongit.push_back(w);
    }
    for(int i = 0;i < nongit.size();++i)
    {
        printf("%05d %d",nongit[i].address,nongit[i].data);
        if(i != nongit.size() - 1)
            printf(" %05d\n",nongit[i+1].address);
        else 
            printf(" -1\n");
    }
    return 0;
}
```

### **1130** **Infix Expression**

> 考点：递归
>
> 总结：重复练习。注意左边数为零可以表示空

```ruby
#include<iostream>
#include<vector>
using namespace std;
struct node
{
    string val;
    int leftl;
    int rightl;
};
int N,root = 1;;
vector<node> te(30);
string dfs(int index)
{
    if(index == -1)
        return "";
    if(te[index].rightl != -1)
    {
        te[index].val = dfs(te[index].leftl) + te[index].val + dfs(te[index].rightl);
        if(index != root)
        te[index].val = "(" + te[index].val + ")";
    }
    return te[index].val;
}
int main()
{
    cin>>N;
    vector<bool> visited(N+1);
    for(int i = 1;i <= N;++i)
    {
        cin>>te[i].val>>te[i].leftl>>te[i].rightl;
        if(te[i].leftl != -1)
            visited[te[i].leftl] = true;
        if(te[i].rightl != -1)
            visited[te[i].rightl] = true;
    }

    while(visited[root] == true)
        root++;
    cout<<dfs(root)<<endl;

    return 0;
}
```

### **1129** **Recommendation System**

> 考点：模拟题，排序
>
> 总结：输出此类商品编号和之前访问最多的前K个编号（如果编号出现次数相同则按照编号的升序排序）

```ruby
#include<iostream>
#include<set>
#include<algorithm>
using namespace std;

const int max_n = 100005;
int  N,K;
struct node
{
    int  value;
    int cnt;
    bool operator<(const node &e)const
    {
        if(cnt != e.cnt)
        {
            return cnt > e.cnt;
        }
        else 
        {
            return value < e.value;
        }
    }
};
int idnum[max_n] = {0};
int main()
{
    cin>>N>>K;
    int num;
    set<node> st;
    for(int i = 0;i < N;++i)
    {
        scanf("%d",&num);
        if(i != 0)
        {
            printf("%d:",num);
            int testnum = 1;
            for(auto it = st.begin();it != st.end() && testnum <= K;++it)
            {
                cout<<" "<<it->value;
                ++testnum;
            }
            printf("\n");
        }
        auto it = st.find({num,idnum[num]});
        if(it != st.end())
            st.erase(it);
        st.insert({num,++idnum[num]});
    }
    return 0;
}
```

#### **1126** **Eulerian Path** 

> 考点：图
>
> 总结：欧拉回路：连通并且每个点的度为偶数。

```ruby
#include<iostream>
#include<vector>
#include<numeric>
#include<algorithm>
using namespace std;

const int max_n = 100005;

vector<vector<int> > G;
int pre[max_n];
int N,M,cnt = 0;
int find(int x)
{
    return pre[x] == x ? x : find(pre[x]);
}
void un(int x,int y)
{
    int nx = find(x),ny = find(y);

    if(nx == ny)
        return ;
    ++cnt;
    pre[nx] = ny;
}
void solve()
{
    int ans =  0,odd = 0;
    for(int i = 1;i <= N;++i)
    {
        if(G[i].size() % 2 == 0)
            ++ans;
        else 
            ++odd;
        cout<<G[i].size()<<(i != N ? " " : "\n");
    }
    if((cnt == N - 1)&&(ans == N))
    {
        cout<<"Eulerian\n";
    }
    else if(odd == 2 && ans + odd == N && cnt == N-1)
    {
        cout<<"Semi-Eulerian\n";
    }
    else 
    {
        cout<<"Non-Eulerian\n";
    }
}
int main()
{
    iota(pre,pre + max_n,0);
    cin>>N>>M;
    G.resize(N+1);

    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        un(x,y);
        G[x].push_back(y);
        G[y].push_back(x);
    }
    solve();
    return 0;
}
```

#### **1125** **Chain the Ropes** 

> 考点：小贪心
>
> 总结：每次串联要使得两个绳子的长度之和减半，为了让最长的绳子减少折叠，排序之后进行计算。从前向后折叠。

```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> st;
int N;
int main()
{
    cin>>N;
    int t;
    for(int i = 0;i < N;++i)
    {
        cin>>t;
        st.push_back(t);
    }
    sort(st.begin(),st.end());
    int result = st[0];
    for(int i = 1;i < N;++i)
        result  = (result + st[i])/2;
    cout<<result<<endl;
    return 0;
}
```

#### **1122** **Hamiltonian Cycle**

> 考点：图的存储，循环
>
> 总结：测试数组是循环；没有不存在的路径；正好走了一圈（除去起点外，没有其他顶点走多次）；每个顶点都路过。



```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
#include<vector>
#include<set>
using namespace std;

const int max_n = 10005;
int edge[max_n][max_n] = {0};
int N,M,K;
int main()
{
    cin>>N>>M;
    for(int i = 0;i < M;++i)
    {
        int x,y;
        cin>>x>>y;
        edge[x][y] = edge[y][x] = 1;
    }
    cin>>K;
    while(K--)
    {
        int nv;
        cin>>nv;
        vector<int> test(nv);
        set<int> st;
        for(int i = 0;i < nv;++i)
        {
            cin>>test[i];
            st.insert(test[i]);
        }
        //包含每个顶点的简单循环
        int cnt = 0;
        bool flag = true;
        for(int i = 1;i < nv;++i)
        {
            if(edge[test[i - 1]][test[i]] == 0)
            {
                flag = false;//有断路
                break;
            }
            ++cnt;
        }
        if((test[0] == test[nv - 1])&&(st.size() == N)&&flag&&(cnt == N))
        {
            cout<<"YES\n";
        }
        else 
        {
            cout<<"NO\n";
        }
    }
    return 0;
}
```

#### **1121** **Damn Single** 

> 考点：
>
> 总结：防止超时，利用map集合存储对应的夫妻（这里利用数组会超出容量），输入测试样例的过程中存在夫妻则将其夫妻删除并且跳过这次id

```ruby
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
#include<set>
#include<unordered_set>
#include<unordered_map>
using namespace std;

const int max_n = 100005;
int N,K;
unordered_map<int,int> couple;

int main()
{
    cin>>N;
    for(int i = 0;i < N;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        couple[x] = y;
        couple[y] = x;
    }
    cin>>K;
    set<int> testees;
    for(int i = 0;i < K;++i)
    {
        int id;
        cin>>id;
       
        if(couple.count(id))
        {
            int couid = couple[id];//是否有配对的
            if(testees.count(couid))
            {
                testees.erase(couple[id]);
                continue;;
            }

        }
        testees.insert(id);
    }
    int nx = testees.size();
    cout<<nx<<endl;
    for(auto &w : testees)
    {
        printf("%05d%s",w,(--nx ? " " : "\n"));
    }

    return 0;
}
```

